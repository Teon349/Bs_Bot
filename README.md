# DogBs Botì´ ë¬´ì—‡ì¸ê°€

# ì„¤ëª…
â“ ë³´í†µ ë””ìŠ¤ì½”ë“œ ë´‡ ê°œë°œì‹œ JS, JAVA, Python ì¤‘ í•˜ë‚˜ë¡œ ê°œë°œí•˜ê²Œ ë˜ëŠ”ë° DPPë¼ëŠ” CPP ê°œë°œ Libë¥¼ ë°œê²¬í–ˆë‹¤ 

ê·¸ë˜ì„œ ê·¸ëƒ¥ ì¬ë°Œì–´ ë³´ì—¬ì„œ DPP ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ë§Œë“¤ê²Œ ë˜ì—ˆë‹¤

# ê·¸ë˜ì„œ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ë°
 ì´ˆë°˜ ë´‡ êµ¬ì¡°ëŠ” DPP + ytdlp êµ¬ì¡°ì˜€ë‹¤. ê°€ì¥ í”í•œ ë°©ë²•ì´ê¸°ë„ í•˜ê³  ì •ë³´ë„ ë§ì´ ìˆë‹¤

 í•˜ì§€ë§Œ ytdlpëŠ” ìœ íŠœë¸Œ ì˜ìƒ ë‹¤ìš´ë¡œë“œë¡œ ê°œë°œë˜ì—ˆê¸°ì— ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ëŒë¦¬ê¸°ì—” ì†ë„ê°€ ë§ì´ ëŠë ¸ë‹¤

 ê·¸ë˜ì„œ ìŠ¤íŠ¸ë¦¬ë° ëª©ì ìœ¼ë¡œ ê°œë°œëœ JAVAê¸°ë°˜ Lavaplayer ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì‚¬ìš©í•˜ëŠ” Lavalinkë¥¼ ì‚¬ìš©í•˜ê²Œ ë˜ì—ˆë‹¤

 ì‚¬ìš© ì–¸ì–´ê°€ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— Lavalinkë¥¼ ìŠ¤íŠ¸ë¦¬ë° ì„œë²„ë¡œ êµ¬ì¶•í•˜ê³  RestAPIë¥¼ ì‚¬ìš©í•˜ì—¬ Socketìœ¼ë¡œ Bot <-> Lavalinkê°€ í†µì‹ í•˜ì—¬
 Botì—ì„œ ìš”ì²­ì„ ë³´ë‚´ê³  Lavalinkê°€ ë°›ì€ ìš”ì²­ì— ë”°ë¼ ë…¸ë˜ ìŠ¤íŠ¸ë¦¬ë°ì„ ë³´ë‚´ëŠ” êµ¬ì¡°ë¡œ ë§Œë“¤ì—ˆë‹¤

 ì—¬ê¸°ì„œ ë‹¨ì ì€ DPPì—ì„œ ë³´ì´ìŠ¤ ì—°ê²°ì„ í•  ë•Œ websocketì„ ë””ìŠ¤ì½”ë“œ ì„œë²„ë¡œ ì—°ê²°í•˜ê²Œ ë˜ëŠ”ë° ì´ë•Œ Lavalinkë„ ìŒì•… ìŠ¤íŠ¸ë¦¬ë°ì„ ìœ„í•´

 ë””ìŠ¤ì½”ë“œ ì„œë²„ë¡œ websocket ì—°ê²°ì„ ë³´ë‚´ê¸° ë•Œë¬¸ì— DPPì˜ wesocket í´ë¼ì´ì–¸íŠ¸ê°€ ë¹„ ì •ìƒì ìœ¼ë¡œ ëŠê¸°ê²Œ ëœë‹¤


**ê·¼ë° ê·¸ëŸ°ëŒ€ë„ ì˜ ëœë‹¤ ê·¸ë˜ì„œ ê·¸ëƒ¥ ì“´ë‹¤**


# êµ¬ì¡°ë‚˜ ë³´ì—¬ë´ 

## main.cpp
í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” mainì´ë‹¤ ë³´í†µ ë´‡ì˜ ìƒí˜¸ì‘ìš©ê³¼ ì»¤ë§¨ë“œ ì²˜ë¦¬ë¥¼ mainì—ì„œ í•˜ê³  botManagerë‚˜ workthreadì— ë„˜ê²¨ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬ëœë‹¤

ì½”ë“œ ë‚´ì—ì„œ ë°œê²¬í•  ìˆ˜ ìˆë“¯ ifdefë¡œ ytdlpë¥¼ ë‚˜ì¤‘ì— ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì¼ë‹¨ì€ ë§Œë“¤ì—ˆë‹¤ 
<details>
<summary>main.cpp </summary>

```cpp
#define _GNU_SOURC
#define _POSIX_C_SOURCE 200809L
#define _XOPEN_SOURCE 700

#include <thread>
#include <chrono>
#include <time.h>
#include <signal.h>
#include "../include/ffmpegPcm.h"
#include "../include/ytdlp.h"
#include "../include/gambling.h"

int interrupt_count = 0;

void handle_signal(int sig) 
{
    switch(sig) 
    {
        case SIGINT:
            interrupt_count++;
            BotLogError << "SIGINT received " << interrupt_count << " times.";
            if (interrupt_count >= 3) 
            {
                BotLogError << "Exiting program after 3 interrupts.";
                exit(0);
            }
        break;
        case SIGTERM:
            BotLogError << "SIGTERM (kill) received!";
            exit(1);
        break;
        case SIGSEGV:
            BotLogError << "SIGSEGV (segmentation fault) received!";
            exit(1);
        break;
        case SIGABRT:
            BotLogError << "SIGABRT (abort) received!";
            exit(1);
        break;
        case SIGFPE:
            BotLogError << "SIGFPE (floating point exception) received!";
            exit(1);
        break;
        default:
            BotLogError << "Unknown signal: " << sig;
            exit(1);
        break;
    }
}

void play_audio_command(std::string stream_url, dpp::snowflake guild) 
{
    if(!g_BotManager->is_connected(guild))
        return;

    if(stream_url.find(MP3_DIR) != std::string::npos)
    {
        try {
            std::thread([guild, stream_url]() {
                send_pcm_to_discord_emoji(guild, stream_url);
            }).detach();
        } catch (const std::exception& e) 
        {
            BotLogError << " play Audio: " << e.what();
        }
    }
    else
    {
        try {
            std::thread([guild, stream_url]() {
                send_pcm_to_discord(guild, stream_url);
            }).detach();
        } catch (const std::exception& e) 
        {
            BotLogError << " play Audio: " << e.what();
        }
    }
    return;
}

void initSignal()
{
    signal(SIGINT,  handle_signal);  // Ctrl+C
    signal(SIGTERM, handle_signal);  // kill
    signal(SIGSEGV, handle_signal);  // segmentation fault
    signal(SIGABRT, handle_signal);  // abort()
    signal(SIGFPE,  handle_signal);
}

void setupDogBs()
{
    initSignal();
    g_BotManager = botManager::getInstance();
    g_taskManager = TaskManager::getInstance();
    g_lavalink = lavalink::getInstance();
    g_gptManager = gptManager::getInstance();

    std::thread worker(workerThread);
    worker.detach();

    g_taskManager->start();

    g_BotManager->initChannelInfo();

    bot.on_log([&](const dpp::log_t& event) 
    {
        if (event.severity >= g_dpploglevel) 
        {
            DPPLog(event.severity) << event.message;
        } 
    });
}


int main() 
{
    std:: cout << R"(     _                                    )" << std::endl;
    std:: cout << R"(    | |                    ______  _____  )" << std::endl;
    std:: cout << R"(  __| |  ___    __ _       | ___ \/  ___| )" << std::endl;
    std:: cout << R"( / _` | / _ \  / _` |      | |_/ /\ `--.  )" << std::endl;
    std:: cout << R"(| (_| || (_) || (_| |      | ___ \ `--. \ )" << std::endl;
    std:: cout << R"( \__,_| \___/  \__, |      | |_/ //\__/ / )" << std::endl;
    std:: cout << R"(                __/ |      \____/ \____/  )" << std::endl;
    std:: cout << R"(               |___/                      )" << std::endl;

    BotLogDebug << "DIR PATH : " << PROJECT_DIR_PATH;

    setupDogBs();

    bot.on_slashcommand([&bot](const dpp::slashcommand_t& event) 
    {
        try {
            dpp::message msg;
            if (event.command.get_command_name() == "play") 
            {
                dpp::guild* g = dpp::find_guild(event.command.guild_id);
                if (!g->connect_member_voice(*event.owner, event.command.get_issuing_user().id)) 
                {
                    event.reply("ë“¤ì–´ì™€ì„œ í‹€ì–´ì„ë§ˆ");
                    return;
                }
                dpp::command_interaction cmd_data = event.command.get_command_interaction();
                std::string option = std::get<std::string>(cmd_data.options[0].value);


                if (!cmd_data.options[0].empty()) 
                {
                    g_BotManager->voiceInfo[event.command.guild_id].req_url = option;
                    g_BotManager->voiceInfo[event.command.guild_id].req_username = event.command.get_issuing_user().username;
                    g_BotManager->voiceInfo[event.command.guild_id].req_userprofile = event.command.get_issuing_user().get_avatar_url();


                    if(g_BotManager->is_connected(event.command.guild_id))
                    {
                        sendSignal(event.command.guild_id, SIG_GET_SONGINFO);
                    }
                    else
                    {
                        g_BotManager->voiceInfo[event.command.guild_id].is_afterPlay = true;
                        g_BotManager->voiceInfo[event.command.guild_id].msg_channel_Id = event.command.channel_id;
                    }
                    msg.set_content("ì–´ ê·¸ë˜ ê¸°ë‹¤ë ¤ í‹€ì–´ì¤„ê²Œ");
                    event.reply(dpp::ir_channel_message_with_source, msg);
                } 
                else 
                {
                    msg.set_content("âŒ URL ì—†ì–ì•„ ì„ë§ˆ");
                    event.reply(dpp::ir_channel_message_with_source, msg);
                }
            } 
            else if (event.command.get_command_name() == "skip")
            {
                if(g_BotManager->is_connected(event.command.guild_id))
                {  
                    msg.set_content("ì´ë†ˆì´ ì´ ë…¸ë˜ê°€ ì‹«ë‹¨ë‹¤ ë„˜ê¸´ë‹¤");
                    event.reply(dpp::ir_channel_message_with_source, msg);
#ifdef USE_LAVALINK
                    if(l_taskQueue.empty() && taskQueue.empty() && !g_BotManager->voiceInfo[event.command.guild_id].is_trackPlaying 
                        && !g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
    #else
                    if(l_taskQueue.empty() && taskQueue.empty() && !g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->is_playing() 
                        && !g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
    #endif
                    {
                        sendSignal(event.command.guild_id, SIG_NEXT_SONG);
                    }
                    else
                    {
    #ifdef USE_LAVALINK
                        g_lavalink->stop_track(std::to_string(event.command.guild_id));
    #else
                        g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->stop_audio();
    #endif
                    }
                }
                else
                    msg.set_content("? ë´‡ì´ ì•„ì§ ì¤€ë¹„ê°€ ì•ˆ ëë‹¤ëŠ”ë°");
                    event.reply(dpp::ir_channel_message_with_source, msg);
            }
            else if (event.command.get_command_name() == "stop") 
            {
                if(!g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
                    g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.clear();
                
                if (g_BotManager->is_connected(event.command.guild_id)) 
                {
                    g_taskManager->clear_guild_queue(event.command.guild_id);
                    g_BotManager->voiceInfo[event.command.guild_id].is_connected = false;
                    // if(vc->voiceclient->is_playing())
                    {

#ifdef USE_LAVALINK
                        g_lavalink->stop_track(std::to_string(event.command.guild_id));
#else
                        g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->stop_audio();
#endif
                        // vc->voiceclient->send_audio_raw(nullptr, 0);
                    }

                    event.from()->disconnect_voice(event.command.guild_id);

                    msg.set_content("â¹ï¸ ë´‡ ì¤‘ì§€ë§¨");
                    event.reply(dpp::ir_channel_message_with_source, msg);
                } 
                else 
                {
                    msg.set_content("âŒ ë´‡ ì„ë§ˆ ì—¬ê¸° ì—†ëŠ”ë°?");
                    event.reply(dpp::ir_channel_message_with_source, msg);
                }
            }
            else if (event.command.get_command_name() == "add")
            {
                g_BotManager->voiceInfo[event.command.guild_id].embed_channel_Id = event.command.channel_id;
                g_BotManager->add_or_update_guild_channel(std::to_string(event.command.guild_id), std::to_string(event.command.channel_id));
                g_BotManager->add_embed_Channel(event.command.guild_id, g_BotManager->voiceInfo[event.command.guild_id].embed_channel_Id);

                msg.set_content("ì±„ë„ ì¶”ê°€ ì™„ë£Œ");
                event.reply(dpp::ir_channel_message_with_source, msg);
            }
            else if (event.command.get_command_name() == "í™€ì§")
            {
                long money;
                long bat_money;
                std::string str;
                json user_data = load_json(GAMBLING_JSONPATH);
                std::string user_id = std::to_string(event.command.get_issuing_user().id);
                money = get_money(user_data, user_id);
                if (money <= 0)
                {
                    if (money == 0)
                        msg.set_content("ì´ìƒˆë¼ã…‹ã…‹ íƒ•ì§„í–ˆë„¤ ã…‹ã…‹ã…‹ã…‹ ë³‘ì‹  ã…‹ã…‹ã…‹ã…‹ ì—¿ì´ë‚˜ ì³ë¨¹ì–´ã…‹");
                    else
                        msg.set_content("ëˆë¶€í„° ë°›ì•„ ì´ìì‹ì•„ì•„");

                    event.reply(dpp::ir_channel_message_with_source, msg);
                }
                else 
                {
                    dpp::command_interaction cmd_data = event.command.get_command_interaction();
                    if (!cmd_data.options.empty())
                    {
                        bat_money = std::get<long>(cmd_data.options[0].value);
                        if(money < bat_money)
                        {
                            msg.set_content("ë‹ˆ ê·¸ ì •ë„ ëˆ ì—†ì–ì•„");
                            event.reply(dpp::ir_channel_message_with_source, msg);
                        }
                        else
                        {
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<> dist(0, 100); // í™•ë¥ 
                            std::uniform_int_distribution<> p_dist(0, 1); // 0 = í™€, 1 = ì§
                            dpp::embed e;

                            int chance = dist(gen);  // ë¨¹íŠ€ í™•ë¥ 
                            int probability = p_dist(gen); // í™€/ì§
                            std::string cmd = (probability == 1) ? "ì§" : "í™€";
                            if (chance == 69)
                            {
                                str = "ì”¨!!!ë°œ í† ì‚¬ì¥ì´ ë¨¹íŠ€ í–ˆìŠµë‹ˆë‹¤ ë³‘ì‹ ã…‹ ë‹ˆ ëˆ : 0";
                                e.set_title("ì”¨!!!!!!ë°œ í† ì‚¬ì¥")
                                .set_color(0xED4245); // ì´ˆë¡ ê³„ì—´
                                e.add_field("í† ì‚¬ì¥ì´ ë¨¹íŠ€ë¥¼ í–ˆìŠµë‹ˆë‹¤", "ë³‘ì‹ ã…‹", false);
                                e.add_field("ë‹ˆ ëˆ : ", "0ì›", false);
                                update_money(user_data, user_id, 0);
                                msg.set_content(str);
                                event.reply(dpp::ir_channel_message_with_source, msg);
                            }
                            else
                            {

                                if ((std::get<std::string>(cmd_data.options[1].value) == "í™€" && probability == 0) || 
                                (std::get<std::string>(cmd_data.options[1].value) == "ì§" && probability == 1))
                                {
                                    e.set_title("ì•„ ì”¨ë°œ ë‚´ ëˆ")
                                    .set_color(0x57F287); // ì´ˆë¡ ê³„ì—´
                                    e.add_field("í™€/ì§", cmd, false);
                                    e.add_field("ë‹ˆ ëˆ : ", std::to_string(money + bat_money) + "ì›", false);

                                    update_money(user_data, user_id, money + bat_money);
                                }
                                else
                                {
                                    e.set_title("ë³‘ì‹ ã…‹")
                                    .set_color(0xED4245); // ë¹¨ê°• ê³„ì—´
                                    e.add_field("í™€/ì§", cmd, false);
                                    e.add_field("ë‹ˆ ëˆ : ", std::to_string(money - bat_money) + "ì›", false);

                                    update_money(user_data, user_id, money - bat_money);
                                }
                            }
                            event.reply(dpp::message().add_embed(e));
                            save_json(GAMBLING_JSONPATH, user_data);
                        }
                    }
                }
                

            }
            else if (event.command.get_command_name() == "ëˆê°€ì ¸ì™€")
            {
                dpp::embed e;
                long money;
                json user_data = load_json(GAMBLING_JSONPATH);
                std::string user_id = std::to_string(event.command.get_issuing_user().id);
                money = get_money(user_data, user_id);
                if (money == -1)
                {
                    add_user(user_data, user_id, 100000);
                    money = 100000;
                    e.set_title("ë•… íŒŒë©´ ëˆì´ ë‚˜ì˜¤ëƒ")
                    .set_color(0x3498DB); // íŒŒë‘
                    e.add_field("ë‹ˆ ëˆ", "+" + std::to_string(money) + "ì›", false);
                }
                else
                {
                    if (claim_daily_reward(user_data, user_id))
                    {
                        money += 100000;
                        e.set_title("ë•… íŒŒë©´ ëˆì´ ë‚˜ì˜¤ëƒ")
                        .set_color(0x3498DB); // íŒŒë‘
                        e.add_field("ë‹ˆ ëˆ", "+" + std::to_string(money) + "ì›", false);
                        update_money(user_data, user_id, money);
                    }
                    else 
                    {
                        e.set_title("ë‹ˆ ëˆ ì³ ë°›ì•˜ì–ì•„")
                        .set_color(0x3498DB); // íŒŒë‘
                        e.add_field("ì”¨ë°œ ë³‘ì‹  ì¢†ê°™ì€ ìƒˆë¼", + " ã…—ã…—", false);
                    }
                }

                save_json(GAMBLING_JSONPATH, user_data);
                event.reply(dpp::message().add_embed(e));

            }
            else if (event.command.get_command_name() == "ë„ì™€ì¤˜ë³´ì„±ë§¨")
            {
                dpp::message msg;
                std::string req_msg;
                std::string resp_msg;
                dpp::command_interaction cmd_data = event.command.get_command_interaction();
                
                if (!cmd_data.options.empty()) 
                {
                    req_msg = std::get<std::string>(cmd_data.options[0].value);
                    
                    event.thinking();
                    msg.set_content(g_gptManager->req_gpt_message(req_msg));
                    event.edit_original_response(msg);
                } 
                else 
                {
                    msg.set_content("ë˜‘ë  ì ì–´ë¼");
                    event.reply(dpp::ir_channel_message_with_source, msg);
                }
            }
        } catch (const std::exception& e) {
            bot.log(dpp::ll_error, std::string("ì˜¤ë¥˜ ë°œìƒ: ") + e.what());
            dpp::message msg;
            msg.set_content("âŒ ì–´ ì‰¬ë¶€ë„ ëª…ë ¹ì´ ì´ìƒí•˜ê²Œ í•˜ì§€ë§ˆ");
            event.reply(dpp::ir_channel_message_with_source, msg);
        }
    });

    bot.on_ready([&bot](const dpp::ready_t& event) 
    {
        if (dpp::run_once<struct register_commands>()) 
        {

            dpp::slashcommand play_cmd("play", "ìŒì•… ì¬ìƒë§¨.", bot.me.id);
            play_cmd.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);
            play_cmd.add_option(dpp::command_option(dpp::co_string, "url", "YouTube URL", true));
            bot.global_command_create(play_cmd);

            dpp::slashcommand stop_cmd("stop", "ìŒì•… ì¤‘ì§€ì¸ë° ê·¸ëƒ¥ ë‚˜ê°€ë²„ë¦¬ëŠ”.", bot.me.id);
            stop_cmd.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);   
            bot.global_command_create(stop_cmd);

            dpp::slashcommand next_cmd("skip", "ì–´ ë‹¤ìŒê³¡ì´ì•¼.", bot.me.id);
            next_cmd.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);   
            bot.global_command_create(next_cmd);

            dpp::slashcommand add_cmd("add", "ê°œë³´ì„±ìš© ìŒì•… ì±„ë„ìƒ 'ê°œë³´ì„± ì†Œí™˜ìˆ ' í•´ë„ ë¨ (ì´ë¯¸ ìˆìœ¼ë©´ ì ˆëŒ€ ê±´ë“¤ì§€ ë§ ê²ƒ).", bot.me.id);
            add_cmd.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);  
            bot.global_command_create(add_cmd);

            dpp::slashcommand gpt_cmd("ë„ì™€ì¤˜ë³´ì„±ë§¨", "ê°œë³´ì„±ì´ ì œê³µí•˜ëŠ” ê³ ê¸‰ ì •ë³´", bot.me.id);
            gpt_cmd.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);
            gpt_cmd.add_option(dpp::command_option(dpp::co_string, "ë‚´ìš©", "ë‚´ìš©ì ìœ¼ì…ˆã…‡ã…‡", true));
            bot.guild_command_create(gpt_cmd, sj_guild_id);

            dpp::slashcommand gambling("í™€ì§", "í—˜í•œ ê¼´ ë³´ê¸° ì „ì— ì‹œë„í•˜ì§€ ë§ˆë¼", bot.me.id);
            gambling.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);
            gambling.add_option(dpp::command_option(dpp::co_integer, "ê¸ˆì•¡", "ë² íŒ…í•  ê¸ˆì•¡ (ì˜ˆ: 1 ì´ìƒ)", true));
            gambling.add_option(dpp::command_option(dpp::co_string, "í™€ì§", "í™€ : ì§ ì ìœ¼ì…ˆ", true));
            bot.guild_command_create(gambling, sj_guild_id);

            dpp::slashcommand money("ëˆê°€ì ¸ì™€", "ì‹¬ê¸°ì •ì´ ì„ ì‚¬í•˜ëŠ” ìì• ë¡œìš´ ì´ì•Œ", bot.me.id);
            money.default_member_permissions  = dpp::permissions(dpp::p_use_application_commands);
            bot.guild_command_create(money, sj_guild_id);

#ifdef USE_LAVALINK
            g_BotManager->BOT_USER_ID = std::to_string(bot.me.id);

            g_lavalink->initLavaLink();

            // g_BotManager->initMp3Encode();
#endif
        }

        // g_BotManager->add_embed_Channel(test_guild_id, target_channel_id);
        // g_BotManager->add_embed_Channel(sj_guild_id, sj_target_channel_id);
    });

    bot.on_message_create([&bot](const dpp::message_create_t& event) 
    {
        // ì±„ë„ ë“±ë¡ ì•ˆëœìƒíƒœ
        if (event.msg.channel_id == g_BotManager->voiceInfo[event.msg.guild_id].embed_channel_Id) 
        {
            // ë©”ì‹œì§€ê°€ ë´‡ì´ ë³´ë‚¸ ë©”ì‹œì§€ê°€ ì•„ë‹Œ ê²½ìš°
            if (event.msg.author.id != bot.me.id) 
            {

                dpp::guild* g = dpp::find_guild(event.msg.guild_id);
                if (!g->connect_member_voice(*event.owner, event.msg.author.id)) 
                {
                    // event.reply("ë“¤ì–´ì™€ì„œ í‹€ì–´ì„ë§ˆ");
                    return;
                }
                std::string option = event.msg.content;


                if (!option.empty()) 
                {
                    g_BotManager->voiceInfo[event.msg.guild_id].req_url = option;

                    g_BotManager->voiceInfo[event.msg.guild_id].req_username = event.msg.author.username;
                    g_BotManager->voiceInfo[event.msg.guild_id].req_userprofile = event.msg.author.get_avatar_url();


                    if(g_BotManager->is_connected(event.msg.guild_id))
                    {
                        sendSignal(event.msg.guild_id, SIG_GET_SONGINFO);
                    }
                    else
                    {
                        g_BotManager->voiceInfo[event.msg.guild_id].is_afterPlay = true;
                        g_BotManager->voiceInfo[event.msg.guild_id].msg_channel_Id = event.msg.channel_id;
                    }
                }

                bot.message_delete(event.msg.id, event.msg.channel_id, [](const dpp::confirmation_callback_t& callback) 
                {
                    if (callback.is_error()) 
                    {
                        BotLogError << "Failed to delete message: " << callback.get_error().message;
                    } 
                    else 
                    {
                        // BotLogDebug << "Message deleted successfully!";
                    }
                });
            }
        }
        else
        {
            if(event.msg.content.find("ê°œë³´ì„± ì†Œí™˜ìˆ ") != std::string::npos)
            {
                g_BotManager->voiceInfo[event.msg.guild_id].embed_channel_Id = event.msg.channel_id;
                g_BotManager->add_or_update_guild_channel(std::to_string(event.msg.guild_id), std::to_string(event.msg.channel_id));
                g_BotManager->add_embed_Channel(event.msg.guild_id, g_BotManager->voiceInfo[event.msg.guild_id].embed_channel_Id);
                
                event.reply("ì±„ë„ ì¶”ê°€ ì™„ë£Œ");
            }

            if((event.msg.content.find("ì”¨ë°œ ê°œë³´ì„± ê³„ì—„ì„ í¬") != std::string::npos) && event.msg.author.id == 683013993903947781)
            {
                g_BotManager->is_martial_law = true;
            }
            else if((event.msg.content.find("ê°œë³´ì„± ê³„ì—„í•´ì œ") != std::string::npos) && event.msg.author.id == 683013993903947781)
            {
                g_BotManager->is_martial_law = false;
            }
        }
    });

    // voice Connection Event
    bot.on_voice_state_update([&bot](const dpp::voice_state_update_t& event) 
    {
        if (event.state.user_id == bot.me.id)
        {
            BotLogDebug << "[Voice Event] guild Id : " << event.state.guild_id;
            if (event.state.channel_id.empty()) // disconnect
            {
                g_BotManager->voiceInfo[event.state.guild_id].is_connected = false;
                BotLogInfo << "[Voice Event] Bot " << event.state.user_id << " left the voice channel.";

                // ì´ˆê¸°í™” ì‘ì—…
                Song tmp = {"", "", "", ""};
                g_BotManager->voiceInfo[event.state.guild_id].is_afterPlay = false;
                if(!g_BotManager->voiceInfo[event.state.guild_id].server_queues.queue.empty())
                    g_BotManager->voiceInfo[event.state.guild_id].server_queues.queue.clear();

                if(g_BotManager->voiceInfo[event.state.guild_id].embed_channel_Id != 0)
                    g_BotManager->update_embed(event.state.guild_id, EMBED_DEFUALT, tmp, "");

#ifdef USE_LAVALINK
                if(g_BotManager->voiceInfo[event.state.guild_id].is_trackPlaying)
                {
                    g_lavalink->stop_track(std::to_string(event.state.guild_id));
                }
#endif
                g_BotManager->voiceInfo[event.state.guild_id].c_voice = event.from()->get_voice(event.state.guild_id);

            } 
            else // connected
            {
                BotLogInfo << "[Voice Event] Bot " << event.state.user_id << " joined channel ID: " << event.state.channel_id;

                // channel idë¡œ guild id ì €ì¥
                g_BotManager->voice_channel_map[event.state.channel_id] = event.state.guild_id;
                // voice c ì €ì¥
                g_BotManager->voiceInfo[event.state.guild_id].c_voice = event.from()->get_voice(event.state.guild_id);
                g_BotManager->voiceInfo[event.state.guild_id].client = event.from();

                if(!g_BotManager->voiceInfo[event.state.guild_id].server_queues.queue.empty())
                    g_BotManager->voiceInfo[event.state.guild_id].server_queues.queue.clear();
                
            }
        }
    });

    // voice Client Ready Event
    bot.on_voice_ready([](const dpp::voice_ready_t& event) {
        BotLogInfo << "[Voice Ready] Voice client is ready!";

        dpp::snowflake guild_id = g_BotManager->getGuildId(event.voice_channel_id);
        g_BotManager->voiceInfo[guild_id].c_voice = event.from()->get_voice(guild_id);

        if(!g_BotManager->voiceInfo[guild_id].c_voice)
            return;

        g_BotManager->voiceInfo[guild_id].is_connected = true;

        // DPP websocket Disconnect. 10.1.* ì´í›„ websocket ì´í›„ë¡œ socket event ì´ìƒ í˜„ìƒìœ¼ë¡œ cpu 100% ì´ìƒ ì˜¬ë¼ê°€ disconnect í•„ìš”
        // g_BotManager->voiceInfo[guild_id].c_voice->voiceclient->on_disconnect();
        
        g_lavalink->update_websocket_status(std::to_string(guild_id));

        if(g_BotManager->voiceInfo[guild_id].is_afterPlay == true && g_BotManager->is_connected(guild_id) == true)
        {
            sendSignal(guild_id, SIG_GET_SONGINFO);
        }
        else if (g_BotManager->voiceInfo[guild_id].is_after_emoji == true && g_BotManager->is_connected(guild_id) == true)
        {
            sendSignal(guild_id, SIG_EMOJI_SONG);
        }
        g_BotManager->voiceInfo[guild_id].is_afterPlay = false;
        g_BotManager->voiceInfo[guild_id].is_after_emoji = false;

    });

    bot.on_button_click([&bot](const dpp::button_click_t& event)
    {

        if (event.custom_id == "stop") 
        {
            if(!g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
                g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.clear();

            if (g_BotManager->is_connected(event.command.guild_id)) 
            {
                g_taskManager->clear_guild_queue(event.command.guild_id);
                g_BotManager->voiceInfo[event.command.guild_id].is_connected = false;
                // if(vc->voiceclient->is_playing())
                {

#ifdef USE_LAVALINK

#else
                    vc->voiceclient->stop_audio();
#endif
                    // vc->voiceclient->send_audio_raw(nullptr, 0);
                }
                event.from()->disconnect_voice(event.command.guild_id);

            } 
            else 
            {
                event.from()->disconnect_voice(event.command.guild_id);
            }
        }
        else if (event.custom_id == "skip") 
        {
            if(g_BotManager->is_connected(event.command.guild_id))
            {  
                // ë…¸ë˜ê°€ ì˜¤ë¥˜ë¡œ ë©ˆì¶˜ ìƒíƒœì—ì„œë„ ë™ì‘
#ifdef USE_LAVALINK
                if(l_taskQueue.empty() && taskQueue.empty() && !g_BotManager->voiceInfo[event.command.guild_id].is_trackPlaying 
                    && !g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
#else
                if(l_taskQueue.empty() && taskQueue.empty() && !g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->is_playing() 
                    && !g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty())
#endif
                {
                    sendSignal(event.command.guild_id, SIG_NEXT_SONG);
                }
                else
                {
#ifdef USE_LAVALINK
                    g_lavalink->stop_track(std::to_string(event.command.guild_id));
#else
                    g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->stop_audio();
#endif
                }
            }
        }
        else if (event.custom_id == "smoke")
        {
            dpp::guild* g = dpp::find_guild(event.command.guild_id);

            if (!g->connect_member_voice(*event.owner, event.command.usr.id)) 
            {
                return;
            }

            if(g_BotManager->is_connected(event.command.guild_id) && l_taskQueue.empty() && taskQueue.empty())
            {
#ifdef USE_LAVALINK
                if (!g_BotManager->voiceInfo[event.command.guild_id].is_trackPlaying)
#else
                if (!g_BotManager->voiceInfo[event.command.guild_id].c_voice->voiceclient->is_playing())
#endif
                {
                    sendSignal(event.command.guild_id, SIG_EMOJI_SONG);
                }
            }
            else
            {
                BotLogInfo << "[Smoke] Voice Client is_after_emoji";
                g_BotManager->voiceInfo[event.command.guild_id].is_after_emoji = true;
            }

        }
        else if (event.custom_id == "shuffle")
        {
            if (g_BotManager->is_connected(event.command.guild_id) && l_taskQueue.empty() && taskQueue.empty())
            {
                if (g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.size() > 1)
                {
                    g_BotManager->shuffle_SongQueue(event.command.guild_id);
                }
            }

        }

        event.reply(dpp::ir_deferred_update_message, "", [](const dpp::confirmation_callback_t& callback) 
        {
            if (callback.is_error()) 
            {
                BotLogError << "Failed to process button click: " << callback.get_error().message;
            }
        });
    });

    //Drop Down ë©”ë‰´ select ë¬´ì‹œí•˜ë„ë¡ 
    bot.on_select_click([&bot](const dpp::select_click_t& event) 
    {
        BotLogInfo << "Select Index : " << event.values[0];

        if(!g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.empty() && 
            g_BotManager->voiceInfo[event.command.guild_id].is_trackPlaying)
        {
            try {
                int idx = std::stoi(event.values[0]);
                if(g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.size() >= idx)
                {
                    Song tmp_song = g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue[idx];
                    g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.erase(g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.begin() + idx);
                    g_BotManager->voiceInfo[event.command.guild_id].server_queues.queue.push_front(tmp_song);

                    g_lavalink->stop_track(std::to_string(event.command.guild_id));
                }

            } catch (const std::invalid_argument& e) {
                BotLogError << "invalid_argument : " << e.what();
            }catch (const std::out_of_range& e) {
                BotLogError << "out_of_range : " << e.what();
            }
        }
        event.reply(dpp::ir_deferred_update_message, "", [](const dpp::confirmation_callback_t& callback) 
        {
            if (callback.is_error()) 
            {
                BotLogError << "Failed to process button click: " << callback.get_error().message;
            }
        });
    });

    bot.start(dpp::st_wait);
    return 0;
}

```
</details>

## botManager.cpp

ë´‡ì˜ ê¸°ë³¸ì ì¸ ì±„ë„ ì •ë³´, ì—°ê²° ìƒíƒœë¥¼ ê´€ë¦¬í•˜ê³  workthreadì— ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•´ ë´‡ì˜ ì „ì²´ì ì¸ íë¦„ì„ ê´€ë¦¬í•œë‹¤

ê°œë°œ ì´ˆê¸°ë¶€í„° ì—¬ëŸ¬ ì„œë²„ì—ì„œ êµ¬ë™ ê°€ëŠ¥í•˜ê²Œ ì„¤ê³„í•´ì„œ ì±„ë„ ì •ë³´ë‚˜ ìŒì„± í´ë¼ì´ì–¸íŠ¸ ìƒíƒœ ê´€ë¦¬ë¥¼ mapìœ¼ë¡œ ê´€ë¦¬í•´

ì§ê´€ì ì´ê³  í¸í•˜ê²Œ ê´€ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤

<details>
<summary>botManager.cpp </summary>
  
```cpp
  
#include <dpp/dpp.h>
#include <unordered_map>
#include <deque>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>
#include "../include/global.h"

botManager::botManager()
{
}

botManager::~botManager()
{
	
}

botManager *botManager::getInstance()
{
	static botManager instance;
	return &instance;
}

void botManager::add_embed_Channel(dpp::snowflake guild, dpp::snowflake channel_id)
{
	dpp::snowflake channel = voiceInfo[guild].embed_channel_Id;
    if (channel == 0) 
    {
        BotLogError << "No valid channel for embedding.";
        return;
    }

	dpp::embed embed = dpp::embed()
		.set_color(0x3498DB) // íŒŒë€ìƒ‰
		.set_title("ì–´ í˜•ì€ ë…¸ë˜ë¥¼ í‹€ ìˆ˜ ìˆì–´")
		.set_description("ì•”ê²ƒë„ ì—†ë…¸") // ìƒˆë¡œìš´ ìƒíƒœ
		.set_thumbnail("")
		.set_footer(
				dpp::embed_footer()
				.set_text("")
				.set_icon("")
			)
		.set_timestamp(time(0));

	// ë©”ì‹œì§€ ìƒì„± ë° ì„ë² ë“œ ì¶”ê°€
	dpp::message msg(channel_id, ""); // ì±„ë„ ID ì„¤ì •
	msg.add_embed(embed); // ì„ë² ë“œ ì¶”ê°€

	// ë²„íŠ¼ ìƒì„±
	if (channel_id == sj_target_channel_id || channel_id == target_channel_id)
	{
		msg.add_component(
			dpp::component()
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
				)
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ ").set_style(dpp::cos_secondary).set_id("skip")
				)
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
				)
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("ğŸš¬ ").set_style(dpp::cos_secondary).set_id("smoke")
				)
		);
	}
	else
	{
		msg.add_component(
			dpp::component()
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
				)
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ 1").set_style(dpp::cos_secondary).set_id("skip")
				)
				.add_component(
					dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
				)
		);
	}

    msg.add_component(
        dpp::component()
            .add_component(
                dpp::component().set_type(dpp::cot_selectmenu)
                .set_placeholder("ì–´ í˜•ì€ ëŒ€ê¸°ì—´ë„ ë³´ì—¬ì¤˜")
                .add_select_option(dpp::select_option("empty", "0", ""))
                .set_id("dropdown")
                .set_disabled(true)
            )
    );

	bot.message_create(msg, [this, guild](const dpp::confirmation_callback_t& callback) {
        if (callback.is_error()) 
        {
            BotLogError << "Failed to create embed message: " << callback.get_error().message;
        } 
        else 
        {
            dpp::message sent_message = std::get<dpp::message>(callback.value);
            voiceInfo[guild].embed_message_Id = sent_message.id;
            dpp::snowflake message_id = sent_message.id;
            dpp::snowflake a_channel_id = sent_message.channel_id;
            BotLogInfo << "[Message Create] Embed message created with ID: " << sent_message.id;

            bot.messages_get(a_channel_id, 100, 0, 0, 0, [&bot, a_channel_id, message_id](const dpp::confirmation_callback_t& callback) 
            {
                if (callback.is_error()) {
                    BotLogError << "Failed to fetch messages: " << callback.get_error().message;
                    return;
                }

                // ë©”ì‹œì§€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                dpp::message_map messages = std::get<dpp::message_map>(callback.value);

                // ê° ë©”ì‹œì§€ ì‚­ì œ
                for (const auto& [id, message] : messages) 
                {
                    if(message.id != message_id)
                    {
                        bot.message_delete(message.id, a_channel_id, [](const dpp::confirmation_callback_t& delete_callback) {
                            if (delete_callback.is_error()) 
                            {
                                BotLogError << "Failed to delete message: " << delete_callback.get_error().message;
                            }
                        });
                    }
                }
            });
        }
    });
	return;
}

void botManager::update_embed(dpp::snowflake guild, EMBED_CMD cmd, Song entry, std::string tumbnail)
{
	dpp::snowflake channel = voiceInfo[guild].embed_channel_Id;
    if (channel == 0) 
    {
        BotLogError << "No valid channel for embedding.";
        return;
    }

    dpp::snowflake message_id = voiceInfo[guild].embed_message_Id;
    if (message_id == 0) 
    {
        BotLogError << "No message ID available to edit.";
        return;
    }
 
    dpp::component dropdown;
	std::string title;
	std::string subtitle;
    std::string url = "";
	dpp::embed embed;
	dpp::message msg;
	if(cmd == EMBED_ADD_QUEUE)
	{
		if(voiceInfo[guild].server_queues.queue.empty())
        {
			subtitle = "total : 0";
            dropdown = dpp::component()
                .add_component(
                    dpp::component().set_type(dpp::cot_selectmenu)
                    .set_placeholder("ì–´ í˜•ì€ ëŒ€ê¸°ì—´ë„ ë³´ì—¬ì¤˜")
                    .add_select_option(dpp::select_option("empty", "0", ""))
                    .set_id("dropdown")
                    .set_disabled(true)
                );
        }
		else
		{
			subtitle = "total : " + std::to_string(voiceInfo[guild].server_queues.queue.size());
            dropdown = dpp::component()
                .add_component(
                    dpp::component().set_type(dpp::cot_selectmenu)
                    .set_placeholder("ì–´ í˜•ì€ ëŒ€ê¸°ì—´ë„ ë³´ì—¬ì¤˜")
                    .add_select_option(
                    dpp::select_option(voiceInfo[guild].server_queues.queue[0].title, "0", ""))
                    .set_id("dropdown")
                    .set_disabled(false)
                );

            for(int i = 1; i < voiceInfo[guild].server_queues.queue.size() && i < 24; i++)
            {
                dropdown.components[0].add_select_option(
                    dpp::select_option(voiceInfo[guild].server_queues.queue[i].title, std::to_string(i), "")
                );
            }
		}

		bot.message_get(message_id, channel, [&bot, channel, subtitle, dropdown](const dpp::confirmation_callback_t& callback) 
        {
			if (callback.is_error()) 
            {
				BotLogError << "Failed to fetch message: " << callback.get_error().message;
				return;
			}

			dpp::message existing_message = std::get<dpp::message>(callback.value);

			if (existing_message.embeds.empty()) 
            {
				BotLogError << "No embeds found in the message to update.";
				return;
			}

            existing_message.components.clear();
            if (channel == sj_target_channel_id || channel == target_channel_id)
            {
                existing_message.add_component(
                    dpp::component()
                        .add_component(
                            dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
                        )
                        .add_component(
                            dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ ").set_style(dpp::cos_secondary).set_id("skip")
                        )
						.add_component(
							dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
						)
                        .add_component(
                            dpp::component().set_type(dpp::cot_button).set_label("ğŸš¬ ").set_style(dpp::cos_secondary).set_id("smoke")
                        )
                );
            }
            else
            {
                existing_message.add_component(
                    dpp::component()
                        .add_component(
                            dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
                        )
                        .add_component(
                            dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ 1").set_style(dpp::cos_secondary).set_id("skip")
                        )
						.add_component(
							dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
						)
                );
            }
			existing_message.embeds[0].set_description(subtitle);
            existing_message.add_component(dropdown);

			// ìˆ˜ì •ëœ ë©”ì‹œì§€ ì „ì†¡
			bot.message_edit(existing_message, [](const dpp::confirmation_callback_t& edit_callback) 
            {
				if (edit_callback.is_error()) 
                {
					BotLogError << "Failed to edit message[202]: " << edit_callback.get_error().message;
				} 
                else 
                {
					// BotLogDebug<< "Message description updated successfully!";
				}
			});
		});
	}
	else
	{
		std::string username;
		std::string userprofile;

		if(cmd == EMBED_DEFUALT)
		{
			title = "ì–´ í˜•ì€ ë…¸ë˜ë¥¼ í‹€ ìˆ˜ ìˆì–´";
			subtitle = "ì•”ê²ƒë„ ì—†ë…¸";
		}
		else
		{
			title = entry.title;
#ifdef USE_LAVALINK
            url = entry.url;
#endif
			if(voiceInfo[guild].server_queues.queue.empty())
				subtitle = "total : 0";
			else
			{
				subtitle = "total : " + std::to_string(voiceInfo[guild].server_queues.queue.size());
			}

			if(!entry.username.empty())
				username = entry.username;
			if(!entry.userprofile.empty())
				userprofile = entry.userprofile;
			
		}
		embed = dpp::embed()
			.set_color(0x3498DB) // íŒŒë€ìƒ‰
			.set_title(title)
            .set_url(url)
			.set_description(subtitle)
			.set_thumbnail(tumbnail)
			.set_footer(
				dpp::embed_footer()
				.set_text(username)
				.set_icon(userprofile)
			)
			.set_timestamp(time(0));

		// ë©”ì‹œì§€ ìƒì„± ë° ì„ë² ë“œ ì¶”ê°€
		msg.id = message_id;
		msg.set_channel_id(channel);
		msg.add_embed(embed);

		if (channel == sj_target_channel_id || channel == target_channel_id)
		{
			msg.add_component(
				dpp::component()
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
					)
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ ").set_style(dpp::cos_secondary).set_id("skip")
					)
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
					)
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("ğŸš¬ ").set_style(dpp::cos_secondary).set_id("smoke")
					)
			);
		}
		else
		{
			msg.add_component(
				dpp::component()
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("â¹ï¸").set_style(dpp::cos_secondary).set_id("stop")
					)
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("â­ï¸ ").set_style(dpp::cos_secondary).set_id("skip")
					)
					.add_component(
						dpp::component().set_type(dpp::cot_button).set_label("ğŸ”€ ").set_style(dpp::cos_secondary).set_id("shuffle")
					)
			);
		}
        

        if(voiceInfo[guild].server_queues.queue.empty())
        {
            dropdown = dpp::component()
                .add_component(
                    dpp::component().set_type(dpp::cot_selectmenu)
                    .set_placeholder("ì–´ í˜•ì€ ëŒ€ê¸°ì—´ë„ ë³´ì—¬ì¤˜")
                    .add_select_option(dpp::select_option("Song", "0", ""))
                    .set_id("dropdown")
                    .set_disabled(true)
                );
        }
        else
        {
            dropdown = dpp::component()
                .add_component(
                    dpp::component().set_type(dpp::cot_selectmenu)
                    .set_placeholder("ì–´ í˜•ì€ ëŒ€ê¸°ì—´ë„ ë³´ì—¬ì¤˜")
                    .add_select_option(dpp::select_option(voiceInfo[guild].server_queues.queue[0].title, "0", ""))
                    .set_id("dropdown")
                    .set_disabled(false)
                );

            for(int i = 1; i < voiceInfo[guild].server_queues.queue.size() && i < 24; i++)
            {
                dropdown.components[0].add_select_option(
                    dpp::select_option(voiceInfo[guild].server_queues.queue[i].title, std::to_string(i), "")
                );
            }
        }
    
        msg.add_component(dropdown);

		bot.message_edit(msg, [](const dpp::confirmation_callback_t& callback) 
		{
			if (callback.is_error()) {
				BotLogError << "Failed to edit message[323]: " << callback.get_error().message;
			} else {
				dpp::message sent_message = std::get<dpp::message>(callback.value);
				// BotLogDebug << "Message edited successfully! " << sent_message.id;
			}
		});
	}
	return;
}

void botManager::add_to_queue(dpp::snowflake guild, Song a_songInfo)
{
	voiceInfo[guild].server_queues.queue.push_back(a_songInfo);
	return;
}

void botManager::play_next(dpp::snowflake guild)
{
#ifdef USE_LAVALINK

    if (voiceInfo[guild].is_trackPlaying)
	{
		g_lavalink->stop_track(std::to_string(guild));
		BotLogInfo << "[Play Next] Stop Audio";
	}
#else
	if (voiceInfo[guild].c_voice->voiceclient->is_playing())
	{
		voiceInfo[guild].c_voice->voiceclient->stop_audio();
		BotLogInfo << "[Play Next] Stop Audio";
	}
 
#endif

	if (!voiceInfo[guild].server_queues.queue.empty())
	{
		Song a_SongInfo = voiceInfo[guild].server_queues.queue.front();
		voiceInfo[guild].server_queues.queue.pop_front();
		BotLogInfo << "[PLAY Next] Next Song : " << a_SongInfo.title;
		if (is_connected(guild))
		{
			std::string msg_s = "ë¹™ì‹ ê°™ì€ ë…¸ë˜ ì‹œì‘ : " + a_SongInfo.title;
			if(voiceInfo[guild].embed_channel_Id != 0)
			{
				update_embed(guild, EMBED_PLAY_SONG, a_SongInfo, a_SongInfo.tumbnail);
			}
			else
				send_Msg(guild, voiceInfo[guild].msg_channel_Id, MSG_PLAY_SONG, msg_s);

#ifdef USE_LAVALINK
            play_audio_command(a_SongInfo.track_id, guild);
#else
			play_audio_command(a_SongInfo.url, guild);
#endif
		}
	}

	return;
}

void botManager::shuffle_SongQueue(dpp::snowflake guild)
{
	BotLogInfo << "[Shuffle] Shuffle Song " << guild;
	std::vector<Song> tmpQ;

	if (voiceInfo[guild].server_queues.queue.size() > 1)
	{
		while (!voiceInfo[guild].server_queues.queue.empty())
		{
			tmpQ.push_back(voiceInfo[guild].server_queues.queue.front());
			voiceInfo[guild].server_queues.queue.pop_front();
		}
		
		std::random_device rd;
    	std::mt19937 g(rd());

		std::shuffle(tmpQ.begin(), tmpQ.end(), g);

		for (const auto& elem : tmpQ) 
		{
        	voiceInfo[guild].server_queues.queue.push_back(elem);
    	}
	}

	update_embed(guild, EMBED_ADD_QUEUE, tmpQ.front(), ""); // tmpQëŠ” ì‚¬ìš©í•˜ì§€ ì•Šì•„ ì„ì‹œë¡œ ë„£ê¸°ë§Œ í•¨
}

void botManager::send_Msg(dpp::snowflake guild, dpp::snowflake channel_id, MSG_TYPE msg_type, std::string text)
{
	if(voiceInfo[sj_guild_id].embed_channel_Id == channel_id || channel_id == 0)
		return;

	if(voiceInfo[guild].c_voice && voiceInfo[guild].c_voice->voiceclient)
	{
		// if(voiceInfo[guild].c_voice->voiceclient->is_connected())
		{
			switch (msg_type)
			{
				case MSG_PLAY_SONG:
					voiceInfo[guild].c_voice->voiceclient->creator->message_create(dpp::message(channel_id, text));
				break;
				case MSG_QUEUE:
					voiceInfo[guild].c_voice->voiceclient->creator->message_create(dpp::message(channel_id, text));
				break;
				case MSG_DISCONNECT:
					voiceInfo[guild].c_voice->voiceclient->creator->message_create(dpp::message(channel_id, text));
				break;
				default:
				break;
			}
		}
	}
}
void botManager::initChannelInfo() 
{
	auto channels = get_all_channels();
	for (const auto& [channel_id, guild_id] : channels) 
	{
        // BotLogDebug << "Channel ID: " << channel_id << ", Guild ID: " << guild_id;
		voiceInfo[static_cast<dpp::snowflake>(guild_id)].embed_channel_Id = static_cast<dpp::snowflake>(channel_id);
		add_embed_Channel(static_cast<dpp::snowflake>(guild_id), voiceInfo[static_cast<dpp::snowflake>(guild_id)].embed_channel_Id);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void botManager::initMp3Encode() 
{
    std::string response = g_lavalink->load_track(MP3_DIR);
    json track_data = json::parse(response);
    if (track_data.contains("data") && track_data["data"].contains("encoded")) 
    {
		local_encoded = track_data["data"]["encoded"];
    } 
    else 
    {
        BotLogError << "Load MP3 INFO FAIL";
    }
}

json botManager::read_json_file(const std::string& file_path) 
{
    std::ifstream file(file_path);
    if (file.is_open()) 
    {
        json j;
        file >> j;
        file.close();
        return j;
    }
    return json{{"channels", json::array()}};
}

void botManager::write_json_file(const std::string& file_path, const json& j) 
{
    std::ofstream file(file_path);
    if (file.is_open()) 
    {
        file << j.dump(4);
        file.close();
    } 
    else 
    {
        BotLogError << "Failed to open file for writing: " << file_path;
    }
}

void botManager::add_or_update_guild_channel(const std::string& guild_id, const std::string& channel_id) 
{
    json data = read_json_file(JSONPATH);
    bool updated = false;

    for (auto& channel : data["channels"]) 
    {
        if (channel["channel_id"] == channel_id) 
        {
            channel["guild_id"] = guild_id;
            updated = true;
            break;
        }
    }

    if (!updated) 
    {
        data["channels"].push_back({
            {"channel_id", channel_id},
            {"guild_id", guild_id}
        });
		
    }

    write_json_file(JSONPATH, data);
    BotLogInfo << "[Update Channel] Saved/Updated channel: " << channel_id << " with guild: " << guild_id;
}
std::vector<std::tuple<std::string, std::string>> botManager::get_all_channels() 
{
    json data = read_json_file(JSONPATH);
    std::vector<std::tuple<std::string, std::string>> channels;

    if (data.contains("channels")) 
    {
        for (const auto& channel : data["channels"]) 
        {
            std::string channel_id = channel["channel_id"].get<std::string>();
            std::string guild_id = channel["guild_id"].get<std::string>();
            channels.emplace_back(channel_id, guild_id);
        }
    }

    return channels;
}

bool botManager::is_connected(dpp::snowflake guild)
{
	if (voiceInfo[guild].c_voice)
	{
		if (voiceInfo[guild].c_voice->voiceclient != nullptr && !voiceInfo[guild].c_voice->channel_id.empty())
		{
			return true;
		}
	}

	return false;
}
```

</details>

## lavalin.cpp
ë´‡ ê¸°ëŠ¥ ì¤‘ ì œì¼ ì¤‘ìš”í•œ ì—­í• ì„ í•˜ëŠ” ì½”ë“œë‹¤ Lavalink ì„œë²„ì™€ í†µì‹ í•˜ëŠ” ì†ŒìŠ¤ë©°
RestAPIë¡œ ìš”ì²­ì„ ë³´ë‚´ê³  lavalinkë¡œ ë¶€í„° ê³¡ ì •ë³´ í˜„ì¬ ì¬ìƒ ìƒíƒœ ì •ë³´ë¥¼ ë°›ê³ 

lavalinkë¡œ ì—°ê²°í•œ ë””ìŠ¤ì½”ë“œ ì„œë²„ì˜ ìŒì„± ìƒíƒœ ê´€ë¦¬ë„ í•˜ê³ ìˆë‹¤

<details>
<summary>lavalink.cpp </summary>

```cpp

#include "../include/global.h"


lavalink::lavalink()
{
}

lavalink::~lavalink()
{
	
}

lavalink *lavalink::getInstance()
{
	static lavalink instance;
	return &instance;
}

void lavalink::stop_track(const std::string& guild_id)
{
    BotLogInfo << "\033[33m" << "[Lavalink]" << "\033[0m" << " Req Stop Audio Track";
    if(!m_session_Id.empty())
        update_player_track(m_session_Id, guild_id, "NULL");
    else
        BotLogError << "Session Id Empty!!";
}

void lavalink::play_audio_track(const std::string& guild_id, const std::string& track_id)
{
    BotLogInfo << "\033[33m" << "[Lavalink]" << "\033[0m" << " Req Start Audio Track";
    if(!m_session_Id.empty())
        update_player_track(m_session_Id, guild_id, track_id);
    else
        BotLogError << "Session Id Empty!!";
}

void lavalink::update_websocket_status(const std::string& guild_id)
{
    BotLogInfo << "\033[33m" << "[Lavalink]" << "\033[0m" << " Req Websocket Update Status : " << guild_id;
    dpp::voiceconn *vc =  g_BotManager->voiceInfo[guild_id].c_voice;

    if(vc && !m_session_Id.empty())
        update_voice_state(m_session_Id, guild_id, vc->token, vc->websocket_hostname, vc->session_id);
    else
        BotLogError << "websocket update err!! vc : " << static_cast<bool>(vc);
}

void lavalink::clientThread(lavalink* instance)
{
    BotLogDebug << "\033[33m" << "[Lavalink]" << "\033[0m" << " Run Client!! ";
    instance->m_client.run();
}

size_t lavalink::write_callback(void* contents, size_t size, size_t nmemb, std::string* output) 
{
    size_t total_size = size * nmemb;
    output->append((char*)contents, total_size);
    return total_size;
}

size_t throw_away(void* contents, size_t size, size_t nmemb, void* userp)
{
    return size * nmemb;
}

void lavalink::update_voice_state(const std::string& session_id, const std::string& guild_id,
                        const std::string& voice_token, const std::string& endpoint, const std::string& voice_session_id) 
{
    CURL* curl = curl_easy_init();
    if (!curl) 
    {
        BotLogError << "Failed to initialize CURL.";
        return;
    }

    std::ostringstream url;
    url << "http://" << LAVALINK_HOST << ":" << LAVALINK_PORT
        << "/v4/sessions/" << session_id << "/players/" << guild_id;

    json voice_payload = 
    {
        {"voice", {
            {"token", voice_token},
            {"endpoint", endpoint},
            {"sessionId", voice_session_id}
        }}
    };

    std::string payload = voice_payload.dump();
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, ("Authorization: " + LAVALINK_PASSWORD).c_str());

    curl_easy_setopt(curl, CURLOPT_URL, url.str().c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, throw_away);
    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK)
        BotLogError << "CURL error: " << curl_easy_strerror(res);

    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);
}

// HTTP GET ìš”ì²­ìœ¼ë¡œ Lavalinkì—ì„œ íŠ¸ë™ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜´
std::string lavalink::load_track(const std::string& identifier) 
{
    CURL* curl = curl_easy_init();
    if (!curl) 
    {
        BotLogError << "Failed to initialize CURL.";
        return "";
    }

    std::ostringstream url;
    url << "http://" << LAVALINK_HOST << ":" << LAVALINK_PORT
        << "/v4/loadtracks?identifier=" << curl_easy_escape(curl, identifier.c_str(), identifier.length());

    std::string response_data;
    curl_easy_setopt(curl, CURLOPT_URL, url.str().c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);

    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, ("Authorization: " + LAVALINK_PASSWORD).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK)
        BotLogError << "CURL error: " << curl_easy_strerror(res);


    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);

    return response_data;
}

std::string lavalink::load_track_by_title(const std::string& identifier) 
{
    CURL* curl = curl_easy_init();
    if (!curl) 
    {
        BotLogError << "Failed to initialize CURL.";
        return "";
    }

    std::ostringstream url;
    url << "http://" << LAVALINK_HOST << ":" << LAVALINK_PORT
        << "/v4/loadtracks?identifier=ytsearch:" << curl_easy_escape(curl, identifier.c_str(), identifier.length());

    std::string response_data;
    curl_easy_setopt(curl, CURLOPT_URL, url.str().c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);

    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, ("Authorization: " + LAVALINK_PASSWORD).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK)
        BotLogError << "CURL error: " << curl_easy_strerror(res);
    

    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);

    return response_data;
}

//tack_id Nullì´ë©´ ì¤‘ì§€
void lavalink::update_player_track(const std::string& session_id, const std::string& guild_id, const std::string& track_id) 
{
    CURL* curl = curl_easy_init();
    if (!curl) 
    {
        BotLogError << "Failed to initialize CURL.";
        return;
    }

    std::ostringstream url;
    url << "http://" << LAVALINK_HOST << ":" << LAVALINK_PORT
        << "/v4/sessions/" << session_id << "/players/" << guild_id;

    json play_payload;
    if(track_id != "NULL")
    {
        play_payload = 
        {
            {"encodedTrack", track_id},
            {"paused", false},
            {"volume", 100}
        };
    }
    else
    {
        play_payload = 
        {
            {"encodedTrack", nullptr}
        };
    }
    

    std::string payload = play_payload.dump();
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, ("Authorization: " + LAVALINK_PASSWORD).c_str());

    curl_easy_setopt(curl, CURLOPT_URL, url.str().c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, throw_away);
    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK)
        BotLogError << "CURL error: " << curl_easy_strerror(res);
    else
        // BotLogDebug << "[INFO] Sent player track update request: " << payload;

    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);
}

// WebSocket Handlers
void lavalink::on_open(client* c, websocketpp::connection_hdl hdl) 
{
    BotLogDebug << "WebSocket connection opened.";
    g_BotManager->initMp3Encode();
}

void lavalink::on_message(client* c, websocketpp::connection_hdl hdl, websocketpp::config::asio_client::message_type::ptr msg) 
{
    // BotLogDebug << "[INFO] Received WebSocket message: " << msg->get_payload();

    json parsed = json::parse(msg->get_payload());

    if (parsed.contains("op")) 
    {
        if(parsed["op"] == "ready")
        {
            m_session_Id = parsed["sessionId"];
            BotLogInfo << "Session ID: " << m_session_Id;
        }
        else if (parsed["op"] == "event" && parsed["type"] == "TrackStartEvent" && !parsed["guildId"].empty())
        {
            dpp::snowflake guild_id = static_cast<dpp::snowflake>(parsed["guildId"].get<std::string>());
            g_BotManager->voiceInfo[guild_id].is_trackPlaying = true;
        }
        else if (parsed["op"] == "event" && parsed["type"] == "TrackEndEvent" && !parsed["guildId"].empty())
        {
            dpp::snowflake guild_id = static_cast<dpp::snowflake>(parsed["guildId"].get<std::string>());
            g_BotManager->voiceInfo[guild_id].is_trackPlaying = false;
        }
    }
}

void lavalink::on_fail(client* c, websocketpp::connection_hdl hdl) 
{
    BotLogError << "WebSocket connection failed.";


    std::string command = "pidof java > /dev/null 2>&1";
    int result = system(command.c_str());

    if(result != 0)
    {
        BotLogError << "Lavalink Is Stopped!!";

        std::thread([this]() {
            std::string server_sh = PROJECT_DIR_PATH + "/lavalink-run.sh";
            system(server_sh.c_str());
        }).detach();
    }
    

    websocketpp::lib::error_code ec;
    m_client.close(hdl,websocketpp::close::status::bad_gateway, "Connection canceled", ec);
        if (ec) {
        BotLogError << "Failed to cancel connection: " << ec.message();
    } else {
        BotLogInfo << "Connection attempt canceled.";
    }

    std::this_thread::sleep_for(std::chrono::seconds(5));

    std::string uri = "ws://" + LAVALINK_HOST + ":" + std::to_string(LAVALINK_PORT) + "/v4/websocket";
    client::connection_ptr con = m_client.get_connection(uri, ec);
    if (ec) 
    {
        BotLogError << "Connection initialization failed: " << ec.message();
        return;
    }
    con->append_header("Authorization", LAVALINK_PASSWORD);
    con->append_header("User-Id", g_BotManager->BOT_USER_ID);
    con->append_header("Client-Name", "dog_bs/1.0");

    BotLogInfo << "\033[33m" << "[Lavalink]" << "\033[0m" << " CONN STATUS : " << con->get_state();
    m_client.connect(con);
    
    std::thread(lavalink::clientThread, g_lavalink).detach();
    
}

void lavalink::on_close(client* c, websocketpp::connection_hdl hdl) 
{
    BotLogInfo << "WebSocket connection closed.";
}

void lavalink::initLavaLink() 
{
    BotLogInfo << "\033[33m" << "[Lavalink]" << "\033[0m" << "InIt Lavalink id : " << g_BotManager->BOT_USER_ID;
    std::string uri = "ws://" + LAVALINK_HOST + ":" + std::to_string(LAVALINK_PORT) + "/v4/websocket";

    try {
        m_client.init_asio();

        m_client.set_open_handler(bind(&lavalink::on_open, this, &m_client, _1));
        m_client.set_message_handler(bind(&lavalink::on_message, this, &m_client, _1, _2));
        m_client.set_fail_handler(bind(&lavalink::on_fail, this, &m_client, _1));
        m_client.set_close_handler(bind(&lavalink::on_close, this, &m_client, _1));

        websocketpp::lib::error_code ec;
        client::connection_ptr con = m_client.get_connection(uri, ec);
        if (ec) 
        {
            BotLogError << "Connection initialization failed: " << ec.message();
            return;
        }

        con->append_header("Authorization", LAVALINK_PASSWORD);
        con->append_header("User-Id", g_BotManager->BOT_USER_ID);
        con->append_header("Client-Name", "dog_bs/1.0");

        m_client.connect(con);
        
        std::thread(lavalink::clientThread, g_lavalink).detach();
        // m_client.run();
    } catch (const std::exception& e) {
        BotLogError << "Exception: " << e.what();
    } catch (...) {
        BotLogError << "Unknown exception occurred.";
    }

    return;
}

```

</details>

## botManager.h
lavalink.cppì™€ botManager.cppì—ì„œ ì‚¬ìš©í•˜ëŠ” í—¤ë” íŒŒì¼ì´ë‹¤ ê° ë©”ì†Œë“œ ë³„ ë™ì‘ ì„¤ëª…ì´ ìˆë‹¤

<details>
<summary>botManager.h </summary>

```cpp
#include <dpp/dpp.h>
#include <unordered_map>
#include <deque>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>
#include <nlohmann/json.hpp> 
#include <websocketpp/config/asio_no_tls_client.hpp>
#include <websocketpp/client.hpp>
#include <curl/curl.h>


typedef websocketpp::client<websocketpp::config::asio_client> client;

using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;
using json = nlohmann::json;

struct Song
{
    std::string title;
    std::string url;
    std::string tumbnail;
    std::string track_id;
    std::string username;
    std::string userprofile;
};

struct ServerQueue
{
    std::deque<Song> queue;
};

typedef enum
{
    MSG_PLAY_SONG,
    MSG_QUEUE,
    MSG_DISCONNECT,
}MSG_TYPE;

typedef enum
{
    EMBED_DEFUALT,
    EMBED_PLAY_SONG,
    EMBED_ADD_QUEUE,
}EMBED_CMD;

typedef enum 
{
    LOG_DEBUG,
    LOG_INFO,
    LOG_ERROR,
    LOG_NONE
} LOG_LEVEL;

struct VoiceChanelInfo
{
    dpp::voiceconn* c_voice;
    dpp::discord_client * client;
    ServerQueue server_queues;
    dpp::snowflake msg_channel_Id;
    dpp::snowflake embed_channel_Id;
    dpp::snowflake embed_message_Id;
    bool is_afterPlay = false;
    bool is_connected = false;
    bool is_after_emoji = false;

    bool is_trackPlaying = false;

    std::string req_url;
    std::string req_username;
    std::string req_userprofile;
};

class botManager
{
    private:
        botManager();
        ~botManager();

    public:

        /**
         * @brief guild idë¡œ ê´€ë¦¬ë˜ëŠ” map, ê° ì„œë²„ì˜ ë´‡ ìƒíƒœ ì •ë³´ë¥¼ ì €ì¥ ê´€ë¦¬
         */
        std::unordered_map<dpp::snowflake, VoiceChanelInfo> voiceInfo; // guild id

        /**
         * @brief guild idë¥¼ callbackìœ¼ë¡œ ë°›ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° channel idë¥¼ í†µí•´ guild idë¥¼ ê´€ë¦¬í•˜ëŠ” map
         */
        std::unordered_map<dpp::snowflake, dpp::snowflake> voice_channel_map; // channel id -> guild id get

        static botManager *getInstance();

        /**
         * @brief channel idë¥¼ í†µí•´ voice_channel_mapì— ì €ì¥ëœ guild idë¥¼ return
         */
        dpp::snowflake getGuildId(dpp::snowflake a_channel_id) { return voice_channel_map[a_channel_id];}

        /**
         * @brief ì„œë²„ì˜ íŠ¹ì • ì±„ë„ì— bot ì±„ë„ ë“±ë¡, jsonìœ¼ë¡œ ê´€ë¦¬í•˜ì—¬ í•œ ë²ˆ ë“±ë¡í•œ ì„œë²„ì— ì§€ì†ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
         * @param  guild íŠ¹ì • ì„œë²„ id
         * @param channel_id íŠ¹ì • ì„œë²„ì˜ ì±„íŒ…ë°© id
         */
        void add_embed_Channel(dpp::snowflake guild, dpp::snowflake channel_id);

        /**
         * @brief ë…¸ë˜ê°€ ë°”ë€Œê±°ë‚˜ embedë¥¼ ì´ˆê¸°í™” ì‹œ í˜¸ì¶œí•˜ì—¬ embed update
         * @param guild ì„œë²„ id
         * @param cmd embed update type ì´ˆê¸°í™”, ë…¸ë˜ ì¶”ê°€, ë…¸ë˜ ì‹œì‘ ë“± typeì— ë”°ë¼ ì •ë³´ ë³€ê²½ ë‚´ìš©ì´ ë‹¤ë¦„
         * @param entry ë…¸ë˜ play ì‹œ í‘œì‹œ ë  í•´ë‹¹ ë…¸ë˜ì˜ title ì •ë³´, cmd typeì´ play song ê²½ìš°ì—ë§Œ ì‚¬ìš© ë¨
         * @param tumbnail ë…¸ë˜ play ì‹œ í‘œì‹œ ë  í•´ë‹¹ ë…¸ë˜ì˜ tumbnail ì •ë³´, cmd typeì´ play song ê²½ìš°ì—ë§Œ ì‚¬ìš© ë¨
         */
        void update_embed(dpp::snowflake guild, EMBED_CMD cmd, Song entry, std::string tumbnail);

        /**
         * @brief íŠ¹ì • ì„œë²„ì˜ voiceInfo mapì— ë…¸ë˜ queue ë“±ë¡ yt-dlpë¥¼ í†µí•´ ë…¸ë˜ ì •ë³´ë¥¼ ê°€ì ¸ ì˜¨ ë’¤ ë“±ë¡ ë¨
         * @param guild ì„œë²„ id
         * @param a_title yt-dlpë¡œ ì¶”ì¶œí•œ ì˜ìƒì˜ title ì •ë³´
         * @param a_stream_url yt-dlpë¡œ ì¶”ì¶œí•œ ì˜ìƒì˜ stream url, ìš°ì„ ìœ¼ë¡œ opus ì½”ë±ì˜ url ì „ë‹¬ í•„ìš”
         * @param a_tumbnail yt-dlpë¡œ ì¶”ì¶œí•œ ì˜ìƒì˜ tumbnail ì •ë³´
         */
        void add_to_queue(dpp::snowflake guild, Song a_songInfo);

        /**
         * @brief ë‹¤ìŒ ê³¡ìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” ë©”ì†Œë“œ ë°”ë¡œ ë‹¤ìŒ ê³¡ìœ¼ë¡œ ë„˜ê¸°ëŠ” ê²ƒì´ ì•„ë‹Œ í˜„ì¬ ê³¡ì„ stop í›„ monitor_voice_client threadë¡œ stop ìƒíƒœ ê°ì§€ í›„ ë‹¤ìŒê³¡ìœ¼ë¡œ ë³€ê²½ 
         * @param guild ì„œë²„ id
         */
        void play_next(dpp::snowflake guild);

        /**
         * @brief í˜„ì¬ê¹Œì§€ ì €ì¥ëœ queueë¥¼ ëœë¤í•˜ê²Œ ì„ìŒ 
         * @param guild ì„œë²„ id
         */
        void shuffle_SongQueue(dpp::snowflake guild);

        /**
         * @brief ë´‡ ìƒíƒœê°€ ë³€ê²½ë  ë•Œ ì„œë²„ì˜ íŠ¹ì • ì±„ë„ì— ë©”ì‹œì§€ ì „ì†¡ embedê°€ ë“±ë¡ëœ ì±„ë„ì˜ ê²½ìš° ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
         * @param guild ì„œë²„ id
         * @param channel_id ë©”ì‹œì§€ë¥¼ ì „ì†¡ í•  channel id
         * @param msg_type ë©”ì‹œì§€ì˜ type [add queue, play song, disconnect]
         * @param text ì „ì†¡ í•  ë©”ì‹œì§€ string
         */
        void send_Msg(dpp::snowflake guild, dpp::snowflake channel_id, MSG_TYPE msg_type, std::string text);
        
        /**
         * @brief ë´‡ ì´ˆê¸°í™” ì‹œ embed channel ì •ë³´ë¥¼ jsonì„ í†µí•´ ì½ì–´ embed ì±„ë„ ë“±ë¡
         */
        void initChannelInfo();
        
        /**
         * @brief MP3ì˜ Encode ì •ë³´ ì´ˆê¸°í™”
         */
        void initMp3Encode();

        /**
         * @brief json íŒŒì¼ì„ ì½ì–´ ì €ì¥ ëœ embed channel Listë¥¼ json í˜•íƒœë¡œ ë¦¬í„´
         * @param file_path ì €ì¥ ëœ json íŒŒì¼ì˜ ê²½ë¡œ
         */
        json read_json_file(const std::string& file_path);

        /**
         * @brief ì±„ë„ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì •ë³´ê°€ ë³€ê²½ ë  ë•Œ json íŒŒì¼ì— write
         * @param file_path ì €ì¥ í•  json íŒŒì¼ì˜ ê²½ë¡œ
         * @param j ì±„ë„ ì •ë³´ë¥¼ json í˜•ì‹ìœ¼ë¡œ ì „ë‹¬
         */
        void write_json_file(const std::string& file_path, const json& j);

        /**
         * @brief embed ì±„ë„ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œ í˜¸ì¶œ
         * @param guild_id ì„œë²„ id
         * @param channel_id embed channel id
         */
        void add_or_update_guild_channel(const std::string& guild_id, const std::string& channel_id);

        /**
         * @brief jsonì— ì €ì¥ ëœ ëª¨ë“  ì±„ë„ ì •ë³´ë¥¼ ì½ì–´ vectorë¡œ return
         */
        std::vector<std::tuple<std::string, std::string>> get_all_channels();

        /**
         * @brief DPP 10.1.3 ì´í›„ë¡œ websocketì´ ëŠì–´ì§€ë©´ is_connectedê°€ falseë¡œ ë˜ì–´ c_voiceì˜ channel_id ê°’ìœ¼ë¡œ ì—°ê²° ìœ ë¬´ íŒë‹¨
         * @param guild_id ì„œë²„ id
         */
        bool is_connected(dpp::snowflake guild);


        std::string LAVALINK_HOST = "localhost";
        int LAVALINK_PORT = 2333;
        std::string LAVALINK_PASSWORD = "youshallnotpass";
        std::string BOT_USER_ID; // Discord ë´‡ í´ë¼ì´ì–¸íŠ¸ ID
        bool is_martial_law = false;

};

class gptManager 
{

    private:
        std::vector<std::pair<std::string, std::string>> m_gptHistory;
    public:

        static gptManager *getInstance();

        std::string req_gpt_message(std::string msg);

        void add_history(const std::string& Req, const std::string& Resp) 
        {
            if (m_gptHistory.size() >= 40) // req + resp Size
                m_gptHistory.erase(m_gptHistory.begin());
            m_gptHistory.emplace_back("user", Req);
            m_gptHistory.emplace_back("assistant", Resp);
        }

        std::vector<std::pair<std::string, std::string>> get_gptHistory() { return m_gptHistory; }

        int get_gptHistorySize() { return m_gptHistory.size(); }

};

class lavalink
{

    private:
        lavalink();
        ~lavalink();

    public:

        static lavalink *getInstance();
        
        /**
         * @brief lavalinkë¡œ playì¤‘ì¸ trackì„ Stop
         * @param  guild ì„œë²„ id
         */
        void stop_track(const std::string& guild_id);
        
        /**
         * @brief lavalinkì— encoded trackì„ ì „ë‹¬í•˜ì—¬ music play
         * @param  guild ì„œë²„ id
         * @param  track_id load_track & load_track_by_titleì„ í†µí•´ ì¶”ì¶œí•œ encoded String
         */
        void play_audio_track(const std::string& guild_id, const std::string& track_id);

        /**
         * @brief Voice ì—°ê²° ì‹œ Websocket ì„œë²„(lavalink)ì— ì—°ê²° ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
         * @param  guild ì„œë²„ id
         */
        void update_websocket_status(const std::string& guild_id);

        /**
         * @brief curlì—ì„œ ì‚¬ìš©í•˜ëŠ” callback í•¨ìˆ˜
         */
        static size_t write_callback(void* contents, size_t size, size_t nmemb, std::string* output);

         /**
         * @brief update_websocket_statusì—ì„œ ì‚¬ìš©ë˜ëŠ” ë©”ì†Œë“œ voice ì—°ê²° ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
         * @param session_id lavalinkì˜ Session Id
         * @param guild_id ì—…ë°ì´íŠ¸ ì‹œí‚¬ guild id
         * @param voice_token voiceconnì˜ Token ê°’
         * @param endpoint voiceconnì˜ websocket_hostname (websocket Endpoint)
         * @param voice_session_id voiceconnì˜ Session Id
         */
        void update_voice_state(const std::string& session_id, const std::string& guild_id,
                            const std::string& voice_token, const std::string& endpoint, const std::string& voice_session_id);
        
        /**
         * @brief lavalinkë¥¼ í†µí•´ youtube track ì •ë³´ ì¶”ì¶œ
         * @param identifier youtube url
         */
        std::string load_track(const std::string& identifier);

        /**
         * @brief lavalinkë¥¼ í†µí•´ youtube track ì •ë³´ ì¶”ì¶œ (title)
         * @param identifier youtube ì˜ìƒì˜ title
         */
        std::string load_track_by_title(const std::string& identifier);


        /**
         * @brief play_audio_trackì—ì„œ ì‚¬ìš©ë˜ëŠ” ë©”ì†Œë“œ lavalinkì— playì‹œí‚¬ track ì •ë³´ ì „ë‹¬
         * @param session_id lavalinkì˜ Session Id
         * @param guild_id ì„œë²„ id
         * @param track_id load_track & load_track_by_titleì„ í†µí•´ ì¶”ì¶œí•œ encoded String
         */
        void update_player_track(const std::string& session_id, const std::string& guild_id, const std::string& track_id);

        /**
         * @brief Lavalinkì—ì„œ ì „ë‹¬í•˜ëŠ” event & Message Callback Handler, Track && Status ì •ë³´ëŠ” on_messageë¥¼ í†µí•´ ë°›ì•„ì˜´
         */
        void on_open(client* c, websocketpp::connection_hdl hdl);
        void on_message(client* c, websocketpp::connection_hdl hdl, websocketpp::config::asio_client::message_type::ptr msg);
        void on_fail(client* c, websocketpp::connection_hdl hdl);
        void on_close(client* c, websocketpp::connection_hdl hdl);

        /**
         * @brief Lavalink ì´ˆê¸°í™” í”„ë¡œê·¸ë¨ê³¼ lavalink client websocket ì—°ê²°
         */
        void initLavaLink();

        /**
         * @brief lavalink clientì™€ ì—°ê²° í›„ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰
         */
        static void clientThread(lavalink* instance);

        /**
         * @brief lavalinkì™€ ì—°ê²° ëœ client
         */
        client m_client;

        /**
         * @brief lavalinkì˜ Session Id
         */
        std::string m_session_Id;
};

void play_next_in_queue(dpp::snowflake guild_id);
```

</details>

## workthread.cpp
ë´‡ì˜ ìƒí˜¸ ì‘ìš©ì„ ë°›ê³  ì‹¤ì œ ì´ë²¤íŠ¸ë“¤ì´ ì²˜ë¦¬ë˜ëŠ” ì½”ë“œë‹¤

ë¹„ë™ê¸°ë¡œ ë™ì‘í•˜ë©° ë°œìƒí•œ ì´ë²¤íŠ¸ë¥¼ workthreadë‚´ì—ì„œ ì²˜ë¦¬í•˜ê²Œ ëœë‹¤ 

ì¥ì ì€ ë¹„ë™ê¸°ë¡œ ëŒì•„ê°€ì„œ ì´ë²¤íŠ¸ ì²˜ë¦¬ë™ì•ˆ ëŒ€ê¸°ìƒíƒœì— ë¹ ì§€ì§€ ì•Šê³  ì´ë²¤íŠ¸ë¥¼ queueë¡œ ê´€ë¦¬í•´ì„œ 

ì´ë²¤íŠ¸ê°€ ë¬´ì‹œë˜ëŠ” ì¼ ì—†ì´ ë™ì‘í•œë‹¤
<details>
<summary>workthread.cpp </summary>

```cpp

#include "../include/ytdlp.h"

TaskManager *TaskManager::getInstance()
{
	static TaskManager instance;
	return &instance;
}

void TaskManager::add_task(dpp::snowflake guild_id, const list_task_bot& task) 
{
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        guild_queues[guild_id].push(task);
    }
    cv.notify_one();
}

void TaskManager::start() 
{
    std::thread([this]() 
    {
        while (true) 
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            cv.wait(lock, [this] 
            {
                return !all_queues_empty() || stop_signal;
            });

            if (stop_signal) 
            {
                BotLogDebug << "[Task Manager] Stopping.";
                break;
            }

            for (auto& [guild_id, queue] : guild_queues) 
            {
                if (!queue.empty()) 
                {
                    list_task_bot task = queue.front();
                    queue.pop();

                    lock.unlock();
                    process_task(guild_id, task);
                    lock.lock();
                }
            }
        }
    }).detach();
}

void TaskManager::stop() 
{
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop_signal = true;
    }
    cv.notify_all();
}
void TaskManager::process_task(dpp::snowflake guild_id, const list_task_bot& task) 
{
    list_task_bot msg = task;

    if(!msg.song_q.title.empty())
    {
        if(g_BotManager->is_connected(msg.guild) == false)
            return;
 
        Song songInfo = msg.song_q;
        if(g_BotManager->is_connected(msg.guild))
        {

            if(msg.msg_id == SIG_PLAYLIST)
            {
#ifdef USE_LAVALINK
                Song a_Song = songInfo;
#else
                Song a_Song = get_youtube_audio_url(songInfo.url);
#endif
                
#ifdef USE_LAVALINK
                if(g_BotManager->voiceInfo[msg.guild].server_queues.queue.empty() && 
                    g_BotManager->voiceInfo[msg.guild].is_trackPlaying == false)
#else
                if(g_BotManager->voiceInfo[msg.guild].server_queues.queue.empty() && 
                    g_BotManager->voiceInfo[msg.guild].c_voice->voiceclient->is_playing() == false)
#endif
                {

                    BotLogInfo << "[Play] Title : " << a_Song.title;
#ifdef USE_LAVALINK
                    play_audio_command(a_Song.track_id, msg.guild);
#else
                    play_audio_command(a_Song.url, msg.guild);
#endif
                    std::string msg_s = "ë¹™ì‹ ê°™ì€ ë…¸ë˜ ì‹œì‘ : " + a_Song.title;
                    if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id != 0)
                    {
                        g_BotManager->update_embed(msg.guild, EMBED_PLAY_SONG, a_Song, a_Song.tumbnail);
                    }
                    else
                        g_BotManager->send_Msg(msg.guild, g_BotManager->voiceInfo[msg.guild].msg_channel_Id, MSG_PLAY_SONG, msg_s);
                }
                else
                {
                    if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id != 0)
                        g_BotManager->update_embed(msg.guild, EMBED_ADD_QUEUE, a_Song, a_Song.tumbnail);
                   
                    g_BotManager->add_to_queue(msg.guild, a_Song);
                }
            }
            else if (msg.msg_id == SIG_ADD_QUEUE)
            {
#ifdef USE_LAVALINK
                if(g_BotManager->voiceInfo[msg.guild].server_queues.queue.empty() && 
                    g_BotManager->voiceInfo[msg.guild].is_trackPlaying == false)
#else
                if(g_BotManager->voiceInfo[msg.guild].server_queues.queue.empty() && 
                    g_BotManager->voiceInfo[msg.guild].c_voice->voiceclient->is_playing() == false)
#endif
                {

#ifdef USE_LAVALINK
                    play_audio_command(songInfo.track_id, msg.guild);
#else
                    play_audio_command(songInfo.url, msg.guild);
#endif
                    std::string msg_s = "ë¹™ì‹ ê°™ì€ ë…¸ë˜ ì‹œì‘ : " + songInfo.title;

                    if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id != 0)
                    {
                        g_BotManager->update_embed(msg.guild, EMBED_PLAY_SONG, songInfo, songInfo.tumbnail);
                    }
                    else
                        g_BotManager->send_Msg(msg.guild, g_BotManager->voiceInfo[msg.guild].msg_channel_Id, MSG_PLAY_SONG, msg_s);
                }
                else
                {
                    g_BotManager->add_to_queue(msg.guild, songInfo);

                    std::string msg_s = "ë­” ìš”ìƒí•œ ë…¸ë˜ ì¶”ê°€ : " + songInfo.title;

                    if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id != 0)
                    {
                        g_BotManager->update_embed(msg.guild, EMBED_ADD_QUEUE, songInfo, songInfo.tumbnail);
                    }
                    else
                        g_BotManager->send_Msg(msg.guild, g_BotManager->voiceInfo[msg.guild].msg_channel_Id, MSG_PLAY_SONG, msg_s);
                }
                BotLogInfo << "[Task Play] Title : " << songInfo.title;
                
            }

            if(!g_BotManager->voiceInfo[msg.guild].req_url.empty())
                g_BotManager->voiceInfo[msg.guild].req_url.clear();
        }
        else
            BotLogError << "[Task] IS NOT CONNECTED";
    }
}
void TaskManager::clear_guild_queue(dpp::snowflake guild_id) 
{
    std::unique_lock<std::mutex> lock(queue_mutex);

    if (guild_queues.find(guild_id) != guild_queues.end()) 
    {
        std::queue<list_task_bot>& queue = guild_queues[guild_id];

        // Queue Clear
        std::queue<list_task_bot> empty;
        std::swap(queue, empty);

    } 
}

bool TaskManager::all_queues_empty() 
{
    for (const auto& [guild_id, queue] : guild_queues) 
    {
        if (!queue.empty()) 
        {
            return false;
        }
    }
    return true;
}

void workerThread() 
{
    BotLogDebug << "[Bot] Thread Start";
    while (true) 
    {
        std::unique_lock<std::mutex> lock(mtx); // ë®¤í…ìŠ¤ ì ê¸ˆ

        // ì‹œê·¸ë„ì´ ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸° 
        cv.wait(lock, [] { return !taskQueue.empty() || stopSignal; });

        if (stopSignal && taskQueue.empty()) 
        {
            BotLogInfo << "[Thread] Worker thread stopping.";
            break;
        }

        while (!taskQueue.empty()) 
        {
            task_bot msg = taskQueue.front();
            taskQueue.pop();
            BotLogInfo << "[Thread] Processing task: " << msg.msg_id;

            lock.unlock();
            if(g_BotManager->is_connected(msg.guild))
            {
                switch (msg.msg_id)
                {
                    case SIG_START_SONG:
                    break;
                    case SIG_EMOJI_SONG:
                        if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id != 0)
                        {
#ifdef USE_LAVALINK
                            play_audio_command(local_encoded, msg.guild);
#else
                            play_audio_command(MP3_DIR, msg.guild);
#endif
                            Song tmp_data;
                            tmp_data.title = "ì˜¤ëŠ˜ë„ ëŒë°°íƒ€ì„";
                            g_BotManager->update_embed(msg.guild, EMBED_PLAY_SONG, tmp_data, "");
                        }
                    break;
                    case SIG_GET_SONGINFO:
                        if(!g_BotManager->voiceInfo[msg.guild].req_url.empty())
                        {
                            std::queue<Song> SongList;

                            list_task_bot list_task;
                            list_task.guild = msg.guild;
                            if(g_BotManager->voiceInfo[msg.guild].req_url.find(HTTPS_KEYWORD) != std::string::npos)
                            {
                                if(g_BotManager->voiceInfo[msg.guild].req_url.find("playlist?") != std::string::npos)
                                {
                                    get_youtube_playList(g_BotManager->voiceInfo[msg.guild].req_url, msg.guild, SongList);
                                    list_task.msg_id = SIG_PLAYLIST;
                                }
                                else
                                {
                                    list_task.song_q = get_youtube_audio_url(g_BotManager->voiceInfo[msg.guild].req_url);
                                    list_task.song_q.username = g_BotManager->voiceInfo[msg.guild].req_username;
                                    list_task.song_q.userprofile = g_BotManager->voiceInfo[msg.guild].req_userprofile;
                                    list_task.msg_id = SIG_ADD_QUEUE;
                                }
                            }
                            else
                            {
                                list_task.song_q = get_youtube_audio_by_title(g_BotManager->voiceInfo[msg.guild].req_url);
                                list_task.song_q.username = g_BotManager->voiceInfo[msg.guild].req_username;
                                list_task.song_q.userprofile = g_BotManager->voiceInfo[msg.guild].req_userprofile;
                                list_task.msg_id = SIG_ADD_QUEUE;
                            }

                            if(list_task.msg_id == SIG_PLAYLIST)
                            {
                                std::string size = std::to_string(SongList.size());
                                std::string msg_s = "ë…¸ë˜ " + size + " ê³¡ ì¶”ê°€ë§¨";
#ifdef USE_LAVALINK
                                if(!SongList.empty())
                                {
                                    list_task.song_q = SongList.front();
                                    g_taskManager->add_task(list_task.guild, list_task);
                                    SongList.pop();

                                    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                                    while(!SongList.empty())
                                    {
                                        g_BotManager->add_to_queue(msg.guild, SongList.front());
                                        SongList.pop();
                                    }
                                }
#else
                                while(!SongList.empty())
                                {
                                    list_task.song_q = SongList.front();
                                    g_taskManager->add_task(list_task.guild, list_task);
                                    SongList.pop();
                                }
#endif
                                if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id == 0)
                                    g_BotManager->send_Msg(msg.guild, g_BotManager->voiceInfo[msg.guild].msg_channel_Id, MSG_QUEUE, msg_s);
                                else
                                {
#ifdef USE_LAVALINK
                                    Song tmp;
                                    g_BotManager->update_embed(msg.guild, EMBED_ADD_QUEUE, tmp, "");
#endif
                                }
                            }
                            else
                            {
                                if(!list_task.song_q.url.empty())
                                {
                                    g_taskManager->add_task(list_task.guild, list_task);
                                }
                            }
                            g_BotManager->voiceInfo[msg.guild].req_url.clear();
                            g_BotManager->voiceInfo[msg.guild].req_username.clear();
                            g_BotManager->voiceInfo[msg.guild].req_userprofile.clear();
                        }
                    break;
                    case SIG_NEXT_SONG:
                        BotLogDebug << "[Thread Next PLAY] Next Song Q Size : " << g_BotManager->voiceInfo[msg.guild].server_queues.queue.size();
                        if(!g_BotManager->voiceInfo[msg.guild].server_queues.queue.empty())
                            g_BotManager->play_next(msg.guild);
                        else
                        {
                            if(g_BotManager->is_connected(msg.guild) && g_BotManager->voiceInfo[msg.guild].client)
                            {
                                BotLogInfo << "[Thread Next Play] Disconnect Try\n";
                                if(g_BotManager->voiceInfo[msg.guild].embed_channel_Id == 0)
                                    g_BotManager->send_Msg(msg.guild, g_BotManager->voiceInfo[msg.guild].msg_channel_Id, MSG_DISCONNECT, "ëŒ€ê¸°ì—´ì´ ì—†ë…¸ í˜• ë‚˜ê°„ë‹¤");

                                g_BotManager->voiceInfo[msg.guild].client->disconnect_voice(msg.guild);
                            }
                    
                        }
                    break;
                    case SIG_FFMPEG_INIT_ERROR:
                        if(g_BotManager->voiceInfo[msg.guild].server_queues.queue.size() > 1)
                        {
                            // init ì—ëŸ¬ê°€ ë°œìƒí•˜ê³  playê°€ ì•ˆë˜ê³  ìˆì„ë•Œ ë‹¤ìŒê³¡
#ifdef USE_LAVALINK
                            if(g_BotManager->is_connected(msg.guild) && g_BotManager->voiceInfo[msg.guild].client &&
                                !g_BotManager->voiceInfo[msg.guild].is_trackPlaying)
#else
                            if(g_BotManager->is_connected(msg.guild) && g_BotManager->voiceInfo[msg.guild].client &&
                                !g_BotManager->voiceInfo[msg.guild].c_voice->voiceclient->is_playing())
#endif
                            {
                                sendSignal(msg.guild, SIG_NEXT_SONG);
                            }
                        }
                    break;
                
                    default:
                    break;
                }
            }
            else
            {

            }
            lock.lock(); // ë‹¤ìŒ ì‘ì—…ì„ ìœ„í•´ ë‹¤ì‹œ ì ê¸ˆ
        }
    }
}

void sendSignal(dpp::snowflake guild_id, Sig_Bot a_msgId)
{
    if (g_BotManager->is_martial_law)
        return;

    BotLogDebug << "[SIG Send] guid : " << guild_id << ", Id : " << a_msgId;
    task_bot a_task;
    a_task.guild = guild_id;
    a_task.msg_id = a_msgId;

    taskQueue.push(a_task);
    cv.notify_one();
    return;
}

```

</details>


